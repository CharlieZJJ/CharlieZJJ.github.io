<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>删除链表的第n个节点</title>
    <link href="/note/Algorithm/List/RemoveNthNodeFromEndofList/"/>
    <url>/note/Algorithm/List/RemoveNthNodeFromEndofList/</url>
    
    <content type="html"><![CDATA[<h4 id="删除链表的倒数第-n-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第 N 个结点</a></h4><p>双指针，首先让fast移动n步，然后fast和slow一起移动即可，最后fast到达不符合条件的节点时，slow正好到达要删除的前一个节点。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_nth_from_end</span>(head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt;, <span class="hljs-keyword">mut</span> n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt; &#123;        <span class="hljs-comment">// 首先定义虚拟头节点</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dummy</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode &#123;            val: -<span class="hljs-number">1</span>,            next: head,        &#125;);        <span class="hljs-comment">// 定义快慢指针</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">fast</span> = &amp;dummy.<span class="hljs-title function_ invoke__">clone</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">slow</span> = &amp;<span class="hljs-keyword">mut</span> dummy;        <span class="hljs-comment">// 首先移动快指针n次</span>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span> &#123;            fast = fast.next.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>();            n -= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 如果下一位是None，那么停止</span>        <span class="hljs-comment">// 此时slow在要删除的节点前一位</span>        <span class="hljs-keyword">while</span> fast.next.<span class="hljs-title function_ invoke__">is_some</span>() &#123;            fast = fast.next.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>();            slow = slow.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        &#125;        slow.next = slow.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>().next.<span class="hljs-title function_ invoke__">take</span>();        dummy.next    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两两交换链表中的结点</title>
    <link href="/note/Algorithm/List/SwapNodesInPairs/"/>
    <url>/note/Algorithm/List/SwapNodesInPairs/</url>
    
    <content type="html"><![CDATA[<h4 id="两两交换链表中的节点"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></h4><p>这道题的主要难点其实也是在于rust写链表的离谱。。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">swap_pairs</span>(head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt; &#123;        <span class="hljs-comment">// 定义虚拟头结点</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dummy</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode &#123;            val: -<span class="hljs-number">1</span>,            next: head,        &#125;);        <span class="hljs-comment">// 设置当前cur为虚拟头</span>        <span class="hljs-comment">// 需要把cur设置为要交换的两个节点的前一个节点</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = dummy.<span class="hljs-title function_ invoke__">as_mut</span>();        <span class="hljs-comment">// 首先保留cur.next</span>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> n) = cur.next.<span class="hljs-title function_ invoke__">take</span>() &#123;            <span class="hljs-comment">// 然后保留cur.next.next</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> nn) = n.next.<span class="hljs-title function_ invoke__">take</span>() &#123;                <span class="hljs-comment">// 这里告诉我们，能先用的变量就先用，尽量按照顺序</span>                n.next = nn.next.<span class="hljs-title function_ invoke__">take</span>();                nn.next = <span class="hljs-title function_ invoke__">Some</span>(n);                cur.next = <span class="hljs-title function_ invoke__">Some</span>(nn);                <span class="hljs-comment">// 将cur设置为cur.next.next</span>                cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>().next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果不能保证cur.next和cur.next.next都有定义</span>                <span class="hljs-comment">// 那么还原cur，直接返回</span>                cur.next = <span class="hljs-title function_ invoke__">Some</span>(n);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 返回头节点</span>        dummy.next    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/note/Algorithm/List/ReverseLinkedList/"/>
    <url>/note/Algorithm/List/ReverseLinkedList/</url>
    
    <content type="html"><![CDATA[<h4 id="反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表</a></h4><p>这道题主要是用双指针来写，cur指向head，pre指向None，每一次将cur指向pre，并将cur置为cur.next（注意要提前保存下来这个值），然后把pre向后移动，直到cur到达None，返回pre即可。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reverse_list</span>(head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = head;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pre</span> = <span class="hljs-literal">None</span>;        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> node) = cur.<span class="hljs-title function_ invoke__">take</span>() &#123;            cur = node.next.<span class="hljs-title function_ invoke__">take</span>();            node.next = pre;            pre = <span class="hljs-title function_ invoke__">Some</span>(node);        &#125;        pre    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计链表</title>
    <link href="/note/Algorithm/List/Design/"/>
    <url>/note/Algorithm/List/Design/</url>
    
    <content type="html"><![CDATA[<h4 id="design-linked-list"><a href="https://leetcode.cn/problems/design-linked-list/">707. DesignLinked List</a></h4><p>这题主要是难在rust写个链表有点费劲。。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 通过结合Option可以定义一个良好的链表的数据结构。</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyLinkedList</span> &#123;    <span class="hljs-keyword">pub</span> val: <span class="hljs-type">i32</span>,    <span class="hljs-keyword">pub</span> next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;MyLinkedList&gt;&gt;,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyLinkedList</span> &#123;    <span class="hljs-comment">// 定义一个dummy_head</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;        MyLinkedList &#123;            val: -<span class="hljs-number">1</span>,            next: <span class="hljs-literal">None</span>,        &#125;    &#125;<span class="hljs-comment">// 获取index对应的元素</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>, index: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-built_in">assert!</span>(index &gt; -<span class="hljs-number">1</span>);        <span class="hljs-comment">// 记录当前是第几个</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 设置cur为head（注意self是dummy_head）</span>        <span class="hljs-comment">// 这里要使用引用，因为不能将next的所有权转移给cur</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = &amp;<span class="hljs-keyword">self</span>.next;        <span class="hljs-comment">// 如果当前cur是Some类型的话</span>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = cur &#123;            <span class="hljs-comment">// 如果正好到了需要获取的位置</span>            <span class="hljs-keyword">if</span> i == index &#123;                <span class="hljs-comment">// 返回值</span>                <span class="hljs-keyword">return</span> node.val;            &#125;            <span class="hljs-comment">// 否则移动到下一位</span>            i += <span class="hljs-number">1</span>;            cur = &amp;node.next;        &#125;        <span class="hljs-comment">// 如果while之中没返回，那么说明index超过了链表的size</span>        -<span class="hljs-number">1</span>    &#125;    <span class="hljs-comment">// 头插</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_at_head</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, val: <span class="hljs-type">i32</span>) &#123;        <span class="hljs-comment">// 首先定义新节点，next设置为self.next</span>        <span class="hljs-comment">// self.next也就是head，也就是说新节点指向了head</span>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(MyLinkedList &#123;            val,            next: <span class="hljs-keyword">self</span>.next.<span class="hljs-title function_ invoke__">take</span>(),        &#125;);        <span class="hljs-comment">// 然后将dummy_head指向新节点</span>        <span class="hljs-keyword">self</span>.next = <span class="hljs-title function_ invoke__">Some</span>(new_node);    &#125;    <span class="hljs-comment">// 尾插</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_at_tail</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, val: <span class="hljs-type">i32</span>) &#123;        <span class="hljs-comment">// 定义新节点，因为尾插，所以next必定是None</span>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(MyLinkedList &#123; val, next: <span class="hljs-literal">None</span> &#125;);        <span class="hljs-comment">// 定义一个迭代变量，初始值是head</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">last_node</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.next;        <span class="hljs-comment">// 如果是Some，那么向后移动</span>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = last_node &#123;            last_node = &amp;<span class="hljs-keyword">mut</span> node.next;        &#125;        <span class="hljs-comment">// 可能会有人想到这里last_node就是none了，为什么还可以解引用赋值呢？</span>        <span class="hljs-comment">// 事实上，考虑58行的代码就能知道，last_node的本质是它前一个结点的next指针的引用</span>        <span class="hljs-comment">// 我们这里直接把next修改到指向ne_node就可以完成尾插</span>        *last_node = <span class="hljs-title function_ invoke__">Some</span>(new_node);    &#125;    <span class="hljs-comment">// 在固定位置插入元素</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_at_index</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: <span class="hljs-type">i32</span>, val: <span class="hljs-type">i32</span>) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 定义cur为dummy，方便之后的统一处理</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = <span class="hljs-keyword">self</span>;        <span class="hljs-comment">// 每次取出下一个元素的node</span>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = cur.next.<span class="hljs-title function_ invoke__">take</span>() &#123;            <span class="hljs-comment">// 如果刚好是要找的位置</span>            <span class="hljs-keyword">if</span> i == index &#123;                <span class="hljs-comment">// 插入新节点，链接到node</span>                <span class="hljs-keyword">let</span> <span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(MyLinkedList &#123;                    val,                    next: <span class="hljs-title function_ invoke__">Some</span>(node),                &#125;);                <span class="hljs-comment">// 把node的前一个结点链接到新节点</span>                cur.next = <span class="hljs-title function_ invoke__">Some</span>(new_node);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// 如果不是对应的index，那么恢复next，开始下一轮循环</span>            i += <span class="hljs-number">1</span>;            cur.next = <span class="hljs-title function_ invoke__">Some</span>(node);            cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>()        &#125;        <span class="hljs-comment">// 处理当size == index的情况</span>        <span class="hljs-keyword">if</span> i == index &#123;            cur.next = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(MyLinkedList &#123; val, next: <span class="hljs-literal">None</span> &#125;))        &#125;    &#125;    <span class="hljs-comment">// 在固定位置删除</span>    <span class="hljs-comment">// 和add_at_index类似</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">delete_at_index</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: <span class="hljs-type">i32</span>) &#123;        <span class="hljs-built_in">assert!</span>(index &gt; -<span class="hljs-number">1</span>);        <span class="hljs-comment">// 定义迭代变量</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = <span class="hljs-keyword">self</span>;        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = cur.next.<span class="hljs-title function_ invoke__">take</span>() &#123;            <span class="hljs-keyword">if</span> i == index &#123;                cur.next = node.next;                <span class="hljs-keyword">break</span>;            &#125;            i += <span class="hljs-number">1</span>;            cur.next = <span class="hljs-title function_ invoke__">Some</span>(node);            <span class="hljs-comment">// Box有Deref的trait，可以看作是引用</span>            cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>()        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移除链表元素</title>
    <link href="/note/Algorithm/List/RemoveElement/"/>
    <url>/note/Algorithm/List/RemoveElement/</url>
    
    <content type="html"><![CDATA[<h4 id="移除链表元素"><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203.移除链表元素</a></h4><p>其实移除链表元素倒还好说，主要是rust写链表挺费劲的。。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_elements</span>(head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt;, val: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;ListNode&gt;&gt; &#123;        <span class="hljs-comment">// 定义一个虚拟头节点，指向head</span>        <span class="hljs-comment">// 为了之后操作的一致性，不必单独处理head</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dummy</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode::<span class="hljs-title function_ invoke__">new</span>(-<span class="hljs-number">1</span>));        dummy.next = head;        <span class="hljs-comment">// 保留前一个结点</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = dummy.<span class="hljs-title function_ invoke__">as_mut</span>();        <span class="hljs-comment">// Option.take会留下None，将Option之中的值取出来</span>        <span class="hljs-comment">// let mut x = Some(2);</span><span class="hljs-comment">// let y = x.take();</span><span class="hljs-comment">// assert_eq!(x, None);</span><span class="hljs-comment">// assert_eq!(y, Some(2));</span>        <span class="hljs-comment">// 如果还没有处理到尾节点</span>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(next) = cur.next.<span class="hljs-title function_ invoke__">take</span>() &#123;            <span class="hljs-comment">// 当前节点的value正好是我们要删除的</span>            <span class="hljs-keyword">if</span> next.val == val &#123;                <span class="hljs-comment">// 把前一个节点的next指针设置成当前节点的下一个节点</span>                <span class="hljs-comment">// cur --&gt; next --&gt; next.next</span>                <span class="hljs-comment">// cur --&gt; next.next</span>                cur.next = next.next                <span class="hljs-comment">// 如果不是的话，我们重新设置好cur.next的值（之前被take了）</span>                <span class="hljs-comment">// 并向后移动一个节点</span>            &#125; <span class="hljs-keyword">else</span> &#123;                cur.next = <span class="hljs-title function_ invoke__">Some</span>(next);                cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>()            &#125;        &#125;        <span class="hljs-comment">// 返回head节点</span>        dummy.next    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rtr_Chapter3</title>
    <link href="/note/Graphics/RealTimeRendering/rtr-chapter3/"/>
    <url>/note/Graphics/RealTimeRendering/rtr-chapter3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有些翻译是我自己认为的翻译，不一定符合常规的翻译</p></blockquote><h1 id="chapter-3-the-graphics-processing-unit">Chapter 3 The GraphicsProcessing Unit</h1><h2 id="data-parallel-architectures">3.1 Data-ParallelArchitectures</h2><p>CPU通过分支预测、指令重排等技术来降低延迟的影响。而GPU通过数千个shadercores来降低延迟。GPU的任务主要是处理类似的数据，因此可以尽可能的使用并行技术来加速。GPU主要是针对吞吐量进行优化，单个shader core的延迟要比CPUcore高得多。</p><p>shaderprogram可以进行数值计算，也可以进行纹理的采集。前者很快，因为可以使用寄存器，而后者则需要访问距离shadercore很远的纹理数据，这可以消耗成百上千个时钟周期，此时shadercore必须等待纹理采样完成。这就出现了延迟。</p><p>GPU采取这样的策略：为每个shadercore提供一定的存储空间，这可以让他在不必等待pixel1的纹理数据，转而处理pixel2，直到全部pixel的数值计算完成之后，此时pixel的纹理数据已经采样完成，可以按照数值计算的方式继续进行处理。这样来看，虽然单个pixel的处理时间加长，但是总体时间显著减少。</p><p>GPU使用SIMD（single instruction, multipledata）使之更进一步。每一个对像素渲染的调用都被称为一个线程（和CPU不同），相同的调用被聚集成组，Nvida称之为warps，AMD称之为wavefronts。这个warps被一定数量的shadercore执行。</p><p>例如之前的pixel，通过warps可以实现每次处理的pixel从1到n（Nvida的n是32，也就是一个warps有32个thread），处理过程类似之前的单处理系统。极大的提高了处理速度。而且swap掉warps的代价非常低。</p><p>假如sp使用了较多的寄存器，那么必然导致会出现更少的thread和warp，因为我们需要一次性载入全部的pixel。这样也就会出现延迟。warps的占用率越高，延迟会越低。</p><p>在sp之中出现的if语句也可能会提高延迟。假如说所有thread执行同样的分支，那么没什么影响，一旦其中某个thread执行了相反的路径，那么GPU将会使全部的thread计算全部的路径结果并抛弃不需要的，极大的影响效率。也就是所谓的thread divergence。</p><p>下图是上述规则的总结：</p><p>sp共有5条指令，其中txr需要耗费较长时间。我们需要光栅一个三角形。对于这个三角形每一个fragment的sp调用，都成为一个thread，4个thread构成一个warp。每个warp之中的thread会在同一时间执行相同的指令。在warp1执行到txr之后将会swap成warp2，如此往复，最后全部完成。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter3/image-20230330163753751.png" alt="image-20230330163753751"><figcaption aria-hidden="true">image-20230330163753751</figcaption></figure><p>下面是GPU之中的流水线图示：</p><p>虚线代表可选，绿色代表可编程控制，蓝色代表可配置，黄色代表固定功能。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter3/image-20230330164056961.png" alt="image-20230330164056961"><figcaption aria-hidden="true">image-20230330164056961</figcaption></figure><h2 id="gpu-pipeline-overview">3.2 GPU Pipeline Overview</h2><p>要注意的是，我们考虑的仅仅是逻辑模型，而非物理模型。物理模型只取决于GPU的制造商。逻辑模型并不代表物理模型的实际实现。下面是各个阶段的概述：</p><ol type="1"><li>VertexShader：顶点着色器是一种着色器，它将单个顶点作为输入，并对其执行操作，如变换、光照和纹理映射等，以生成渲染的最终输出。</li><li>Tessellation：曲面细分是一种技术，它可以将简单的几何形状转换为更复杂的形状。它可以用于创建更高质量的曲面和细节。</li><li>GeometryShader：几何着色器是一种着色器，它接受来自顶点着色器的几何数据，可以对几何图形进行处理，例如生成新的几何形状、裁剪几何图形等。</li><li>Clipping：裁剪是在渲染管道中用于删除超出视锥体范围的几何图形的过程。它是一个必要的步骤，以避免不必要的计算和提高渲染性能。</li><li>ScreenMapping：屏幕映射是将三维物体投影到二维屏幕上的过程。在这个过程中，需要将视图矩阵和投影矩阵应用于顶点，以生成最终的屏幕空间坐标。</li><li>Triangle Setup &amp;Traversal：三角形设置是指将顶点转换为三角形的过程，三角形遍历是指将三角形发送到像素着色器进行处理的过程。这是图形管道中的两个重要步骤。</li><li>PixelShader：像素着色器是一种着色器，它接受来自三角形遍历的像素数据，并对其执行操作，如颜色计算、光照和纹理映射等，以生成最终的像素颜色。</li><li>Merger：合并器是将多个像素着色器输出的颜色值进行合并的部件。它可以执行不同的操作，如混合、遮罩和颜色调整等，以生成最终的渲染图像。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Real-Time Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/note/Algorithm/Array/SpiralMatrix/"/>
    <url>/note/Algorithm/Array/SpiralMatrix/</url>
    
    <content type="html"><![CDATA[<h4 id="螺旋矩阵-ii"><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></h4><p>这道题主要问题是细节的把握，主要问题是要掌握好边界的处理和循环不变式的控制。</p><figure><img src="/note/Algorithm/Array/SpiralMatrix/20220922102236.png" alt="本图取自于代码随想录，如有侵权立即删除"><figcaption aria-hidden="true">本图取自于代码随想录，如有侵权立即删除</figcaption></figure><p>最重要的问题是四个边角的处理，到底哪一次循环来做这些任务？一个很重要的想法就是：保证每次循环做的任务类似！例如红色我们只处理开始点，不处理结束点，对于绿色、橙色和棕色都是这样。这就是循环不变式：<span class="math inline">\([start,end)\)</span>。注意到了这一点就不难了。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_matrix</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = n <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; n]; n];        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> start_x, <span class="hljs-keyword">mut</span> start_y, <span class="hljs-keyword">mut</span> offset, <span class="hljs-keyword">mut</span> count) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1i32</span>);        <span class="hljs-keyword">while</span> offset &lt;= n / <span class="hljs-number">2</span> &#123;            <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> i, <span class="hljs-keyword">mut</span> j) = (start_x, start_y);            <span class="hljs-keyword">while</span> j &lt; n - offset &#123;                ret[i][j] = count;                count += <span class="hljs-number">1</span>;                j += <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">while</span> i &lt; n - offset &#123;                ret[i][j] = count;                count += <span class="hljs-number">1</span>;                i += <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">while</span> j &gt; start_y &#123;                ret[i][j] = count;                count += <span class="hljs-number">1</span>;                j -= <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">while</span> i &gt; start_x &#123;                ret[i][j] = count;                count += <span class="hljs-number">1</span>;                i -= <span class="hljs-number">1</span>;            &#125;            start_x += <span class="hljs-number">1</span>;            start_y += <span class="hljs-number">1</span>;            offset += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;            ret[n / <span class="hljs-number">2</span>][n / <span class="hljs-number">2</span>] = count;        &#125;        ret    &#125;&#125;</code></pre></div><h4 id="螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><h4 id="剑指-offer-29.-顺时针打印矩阵"><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指Offer 29. 顺时针打印矩阵</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">spiral_order</span>(matrix: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> (m, n) = (matrix.<span class="hljs-title function_ invoke__">len</span>(), matrix[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">len</span>());        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> top, <span class="hljs-keyword">mut</span> bottom, <span class="hljs-keyword">mut</span> left, <span class="hljs-keyword">mut</span> right) =            (<span class="hljs-number">0i32</span>, (m - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>, <span class="hljs-number">0i32</span>, (n - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span> = <span class="hljs-built_in">vec!</span>[];        <span class="hljs-keyword">let</span> <span class="hljs-variable">max</span> = m * n;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">remain</span> = max;        <span class="hljs-keyword">while</span> remain &gt; <span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j</span> = left;            <span class="hljs-keyword">while</span> j &lt;= right &amp;&amp; remain &gt; <span class="hljs-number">0</span> &#123;                ret.<span class="hljs-title function_ invoke__">push</span>(matrix[top <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>][j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]);                j += <span class="hljs-number">1</span>;                remain -= <span class="hljs-number">1</span>;            &#125;            top += <span class="hljs-number">1</span>;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = top;            <span class="hljs-keyword">while</span> i &lt;= bottom &amp;&amp; remain &gt; <span class="hljs-number">0</span> &#123;                ret.<span class="hljs-title function_ invoke__">push</span>(matrix[i <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>][right <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]);                i += <span class="hljs-number">1</span>;                remain -= <span class="hljs-number">1</span>;            &#125;            right -= <span class="hljs-number">1</span>;            j = right;            <span class="hljs-keyword">while</span> j &gt;= left &amp;&amp; remain &gt; <span class="hljs-number">0</span> &#123;                ret.<span class="hljs-title function_ invoke__">push</span>(matrix[bottom <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>][j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]);                j -= <span class="hljs-number">1</span>;                remain -= <span class="hljs-number">1</span>;            &#125;            bottom -= <span class="hljs-number">1</span>;            i = bottom;            <span class="hljs-keyword">while</span> i &gt;= top &amp;&amp; remain &gt; <span class="hljs-number">0</span> &#123;                ret.<span class="hljs-title function_ invoke__">push</span>(matrix[i <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>][left <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]);                i -= <span class="hljs-number">1</span>;                remain -= <span class="hljs-number">1</span>;            &#125;            left += <span class="hljs-number">1</span>;        &#125;        ret    &#125;&#125;</code></pre></div><p>发现了一个比我优雅的多的写法！！！</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">spiral_order</span>(matrix: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> top, <span class="hljs-keyword">mut</span> left) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> bottom, <span class="hljs-keyword">mut</span> right) = (matrix.<span class="hljs-title function_ invoke__">len</span>(), matrix[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">len</span>());        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = <span class="hljs-built_in">vec!</span>[];        <span class="hljs-comment">// counter clockwise direction</span>        <span class="hljs-comment">// 0 -&gt; right, 1 -&gt; down, 2 -&gt; left, 3 -&gt; up</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dir</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">while</span> top &lt; bottom &amp;&amp; left &lt; right &#123;            <span class="hljs-keyword">let</span> (x, y) = cur;            <span class="hljs-keyword">match</span> dir &#123;                <span class="hljs-number">0</span> =&gt; &#123;                    result.<span class="hljs-title function_ invoke__">extend</span>((left..right).<span class="hljs-title function_ invoke__">map</span>(|y| matrix[x][y]));                    top += <span class="hljs-number">1</span>;                    cur = (x, right - <span class="hljs-number">1</span>);                &#125;                <span class="hljs-number">1</span> =&gt; &#123;                    result.<span class="hljs-title function_ invoke__">extend</span>((top..bottom).<span class="hljs-title function_ invoke__">map</span>(|x| matrix[x][y]));                    right -= <span class="hljs-number">1</span>;                    cur = (bottom - <span class="hljs-number">1</span>, y);                &#125;                <span class="hljs-number">2</span> =&gt; &#123;                    result.<span class="hljs-title function_ invoke__">extend</span>((left..right).<span class="hljs-title function_ invoke__">rev</span>().<span class="hljs-title function_ invoke__">map</span>(|y| matrix[x][y]));                    bottom -= <span class="hljs-number">1</span>;                    cur = (x, left);                &#125;                <span class="hljs-number">3</span> =&gt; &#123;                    result.<span class="hljs-title function_ invoke__">extend</span>((top..bottom).<span class="hljs-title function_ invoke__">rev</span>().<span class="hljs-title function_ invoke__">map</span>(|x| matrix[x][y]));                    left += <span class="hljs-number">1</span>;                    cur = (top, y);                &#125;                _ =&gt; <span class="hljs-built_in">unreachable!</span>(),            &#125;            dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;        &#125;        result    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长度最小的子数组</title>
    <link href="/note/Algorithm/Array/MinimumSizeSubArraySum/"/>
    <url>/note/Algorithm/Array/MinimumSizeSubArraySum/</url>
    
    <content type="html"><![CDATA[<h4 id="长度最小的子数组"><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></h4><p>暴力法很容易想到，就是枚举窗口的起始位置和终止位置：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::min;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">min_sub_array_len</span>(target: <span class="hljs-type">i32</span>, nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span> = <span class="hljs-type">usize</span>::MAX;        <span class="hljs-keyword">let</span> <span class="hljs-variable">sz</span> = nums.<span class="hljs-title function_ invoke__">len</span>();          <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..sz &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> i..sz &#123;                sum += nums[j];                <span class="hljs-keyword">if</span> sum &gt;= target &#123;                    ret = <span class="hljs-title function_ invoke__">min</span>(j - i + <span class="hljs-number">1</span>, ret);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;                        &#125;        <span class="hljs-keyword">if</span> ret == <span class="hljs-type">usize</span>::MAX &#123;            <span class="hljs-number">0</span>        &#125; <span class="hljs-keyword">else</span> &#123;            ret <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>        &#125;    &#125;&#125;</code></pre></div><p>接下来是滑动窗口。所谓的滑动窗口，就是用一个for完成两个for的事情。我们只用一个指针就可以完成迭代（通过技巧在修改某个指针的时候将另外一个指针也进行修改）。那么这个指针应该代表起始位置还是终止位置呢？假设一下：</p><ul><li>起始位置，如果代表起始位置的话，和暴力法没啥区别，因为还是要暴力枚举后面的数</li><li>终止位置，可以在移动的过程中通过某种策略移动起始位置，完成了去掉for的操作。</li></ul><p>指针不断后移，当<span class="math inline">\(sum \getarget\)</span>的时候，触发移动起始位置的操作，不断移动起始位置直到不再满足<span class="math inline">\(sum \getarget\)</span>，过程中不断更新ret的值即可。</p><figure><img src="/note/Algorithm/Array/MinimumSizeSubArraySum/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="本图取自于代码随想录，如有侵权立即删除"><figcaption aria-hidden="true">本图取自于代码随想录，如有侵权立即删除</figcaption></figure><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::min;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">min_sub_array_len</span>(target: <span class="hljs-type">i32</span>, nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> start, <span class="hljs-keyword">mut</span> sum, <span class="hljs-keyword">mut</span> ret) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-type">usize</span>::MAX);        <span class="hljs-keyword">let</span> <span class="hljs-variable">sz</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-comment">// 这里还可以用</span>        <span class="hljs-comment">// for (pos, val) in nums.iter().enumerate()</span>        <span class="hljs-keyword">for</span> <span class="hljs-variable">end</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..sz &#123;            sum += nums[end];            <span class="hljs-keyword">while</span> sum &gt;= target &#123;                ret = <span class="hljs-title function_ invoke__">min</span>(ret, end - start + <span class="hljs-number">1</span>);                sum -= nums[start];                start -= <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">match</span> ret &#123;            <span class="hljs-type">usize</span>::MAX =&gt; <span class="hljs-number">0</span>,            r =&gt; r <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>,        &#125;    &#125;&#125;</code></pre></div><h4 id="水果成篮"><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮</a></h4><p>这题挺有趣的，他是找的最大窗口，上面内个题找的是最小窗口。要注意的就是，找最小和找最大不同。最小要求在每次更新start的时候更新ret，而最大要求在更新完start之后再去更新ret：</p><div class="code-wrapper"><pre><code class="hljs pseudocode">// 最小while j &lt; len(nums):    判断[i, j]是否满足条件    while 满足条件：        不断更新结果(注意在while内更新！)        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）    j += 1</code></pre></div><div class="code-wrapper"><pre><code class="hljs pseudocode">// 最大while j &lt; len(nums):    判断[i, j]是否满足条件    while 不满足条件：        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）    不断更新结果（注意在while外更新！）    j += 1</code></pre></div><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::max;<span class="hljs-keyword">use</span> std::collections::HashMap;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">total_fruit</span>(fruits: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bucket</span>: HashMap&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> start, <span class="hljs-keyword">mut</span> ret, <span class="hljs-keyword">mut</span> sum) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-title function_ invoke__">for</span> (_, val) <span class="hljs-keyword">in</span> fruits.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">ent</span> = bucket.<span class="hljs-title function_ invoke__">entry</span>(*val).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);            *ent += <span class="hljs-number">1</span>;            sum += <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> bucket.<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">2</span> &#123;                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(ent) = bucket.<span class="hljs-title function_ invoke__">get_mut</span>(&amp;fruits[start]) &#123;                    *ent -= <span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span> *ent == <span class="hljs-number">0</span> &#123;                        bucket.<span class="hljs-title function_ invoke__">remove</span>(&amp;fruits[start]);                    &#125;                &#125;                start += <span class="hljs-number">1</span>;                sum -= <span class="hljs-number">1</span>;            &#125;            ret = <span class="hljs-title function_ invoke__">max</span>(sum, ret);        &#125;        ret    &#125;&#125;</code></pre></div><h4 id="最小覆盖子串"><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></h4><p>比较慢的实现，但是功能都很全hhh</p><p>第一道困难题！</p><p>有时间来优化一下试试。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">min_window</span>(s: <span class="hljs-type">String</span>, t: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">start</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">char</span>&gt; = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">t_table</span>: HashMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s_table</span>: HashMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span> = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> t.<span class="hljs-title function_ invoke__">chars</span>() &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">entry</span> = t_table.<span class="hljs-title function_ invoke__">entry</span>(c).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);            *entry += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-title function_ invoke__">for</span> (end, val) <span class="hljs-keyword">in</span> ss.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">entry</span> = s_table.<span class="hljs-title function_ invoke__">entry</span>(*val).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);            *entry += <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">table_contains</span>(&amp;s_table, &amp;t_table) &#123;                <span class="hljs-keyword">if</span> ret.<span class="hljs-title function_ invoke__">len</span>() &gt; end - start + <span class="hljs-number">1</span> || ret == <span class="hljs-string">&quot;&quot;</span> &#123;                    ret = &amp;s[start..=end];                &#125;                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = s_table.<span class="hljs-title function_ invoke__">get_mut</span>(&amp;ss[start]) &#123;                    *s -= <span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span> *s == <span class="hljs-number">0</span> &#123;                        s_table.<span class="hljs-title function_ invoke__">remove</span>(&amp;ss[start]);                    &#125;                    start += <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        ret.<span class="hljs-title function_ invoke__">to_string</span>()    &#125;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">table_contains</span>(s: &amp;HashMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">i32</span>&gt;, t: &amp;HashMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-title function_ invoke__">for</span> (key, val) <span class="hljs-keyword">in</span> t.<span class="hljs-title function_ invoke__">iter</span>() &#123;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(k) = s.<span class="hljs-title function_ invoke__">get</span>(key) &#123;                <span class="hljs-keyword">if</span> k &lt; val &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-literal">true</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移除数组元素</title>
    <link href="/note/Algorithm/Array/RemoveElement/"/>
    <url>/note/Algorithm/Array/RemoveElement/</url>
    
    <content type="html"><![CDATA[<h4 id="移除元素"><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a></h4><p>首先是暴力法，也就是两层for，外层遇到target的时候就开启内层，将target之后的元素依次前移即可。唯一要注意的地方就是当数组整体前移1位的时候，i也需要前移1位。</p><figure><img src="/note/Algorithm/Array/RemoveElement/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif" alt="本图取自于代码随想录，如有侵权立即删除"><figcaption aria-hidden="true">本图取自于代码随想录，如有侵权立即删除</figcaption></figure><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_element</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, val: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sz</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> i &lt; sz &#123;            <span class="hljs-keyword">if</span> nums[i] == val &#123;                <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> i + <span class="hljs-number">1</span>..sz &#123;                    nums[j - <span class="hljs-number">1</span>] = nums[j];                &#125;                sz -= <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                i += <span class="hljs-number">1</span>;            &#125;        &#125;        sz <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>    &#125;&#125;</code></pre></div><p>接下来是双指针法。其中快指针指向的是移除之后的数组之中应该存在的元素，而慢指针就是快指针指向元素在新数组的下标。理解了这个，代码就好写了。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_element</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, val: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">sz</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">slowIndex</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. sz &#123;            <span class="hljs-keyword">if</span> nums[fastIndex] != val &#123;                nums[slowIndex] = nums[fastIndex];                slowIndex += <span class="hljs-number">1</span>;            &#125;        &#125;        slowIndex <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>    &#125;&#125;</code></pre></div><figure><img src="/note/Algorithm/Array/RemoveElement/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="本图取自于代码随想录，如有侵权立即删除"><figcaption aria-hidden="true">本图取自于代码随想录，如有侵权立即删除</figcaption></figure><h4 id="删除有序数组中的重复项"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除有序数组中的重复项</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_duplicates</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">slowIndex</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..nums.<span class="hljs-title function_ invoke__">len</span>() &#123;            <span class="hljs-keyword">if</span> nums[slowIndex] != nums[fastIndex] &#123;                slowIndex += <span class="hljs-number">1usize</span>;                nums[slowIndex] = nums[fastIndex];            &#125;        &#125;        slowIndex <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> + <span class="hljs-number">1</span>    &#125;&#125;</code></pre></div><h4 id="移动零"><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">move_zeroes</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">slowIndex</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..nums.<span class="hljs-title function_ invoke__">len</span>() &#123;            <span class="hljs-keyword">if</span> nums[fastIndex] != <span class="hljs-number">0</span> &#123;                nums[slowIndex] = nums[fastIndex];                slowIndex += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> <span class="hljs-variable">ptr</span> <span class="hljs-keyword">in</span> slowIndex..nums.<span class="hljs-title function_ invoke__">len</span>() &#123;            nums[ptr] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h4 id="比较含退格的字符串"><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">backspace_compare</span>(s: <span class="hljs-type">String</span>, t: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">removeSharp</span>(s);        <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">removeSharp</span>(t);        s == t    &#125;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">removeSharp</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ss</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">char</span>&gt; = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">collect</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span> = <span class="hljs-built_in">vec!</span>[];        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">slow_index</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-variable">sz</span> = s.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">for</span> <span class="hljs-variable">fast_index</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..sz &#123;            <span class="hljs-keyword">if</span> ss[fast_index] != <span class="hljs-string">&#x27;#&#x27;</span> &#123;                ss[slow_index] = ss[fast_index];                slow_index += <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> slow_index != <span class="hljs-number">0</span> &#123;                    slow_index -= <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..slow_index &#123;            ret.<span class="hljs-title function_ invoke__">push</span>(ss[i]);        &#125;        ret.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>()    &#125;&#125;</code></pre></div><h4 id="有序数组的平方"><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></h4><p>首先是最简单的暴力法，复杂度是<span class="math inline">\(O(n + n\log n)\)</span></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sorted_squares</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nums</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = nums.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * x).<span class="hljs-title function_ invoke__">collect</span>();        nums.<span class="hljs-title function_ invoke__">sort</span>();        nums    &#125;&#125;</code></pre></div><p>然后是双指针。这个数组是排好序的，平方后仍然有一定的大小关系，也就是说最大的一定出现在两侧，而最小的一定出现在靠中间的位置，而且从两边到中间一定是递减的。有了这个特定就可以类似merge一样操作数组了。</p><figure><img src="/note/Algorithm/Array/RemoveElement/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="本图取自于代码随想录，如有侵权立即删除"><figcaption aria-hidden="true">本图取自于代码随想录，如有侵权立即删除</figcaption></figure><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sorted_squares</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> i, <span class="hljs-keyword">mut</span> j, <span class="hljs-keyword">mut</span> k) = (<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n);        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; n];        <span class="hljs-keyword">let</span> <span class="hljs-variable">nums</span> = nums.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * x).collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;();        <span class="hljs-keyword">while</span> i &lt;= j &#123;            <span class="hljs-keyword">if</span> nums[i] &lt; nums[j] &#123;                ans[k - <span class="hljs-number">1</span>] = nums[j];                j -= <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                ans[k - <span class="hljs-number">1</span>] = nums[i];                i += <span class="hljs-number">1</span>;            &#125;            k -= <span class="hljs-number">1</span>;        &#125;        ans    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/note/Algorithm/Array/BinarySearch/"/>
    <url>/note/Algorithm/Array/BinarySearch/</url>
    
    <content type="html"><![CDATA[<h4 id="二分查找"><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></h4><p>二分搜索最重要的是掌握现在是根据什么区间来写的。</p><p>一般情况下，二分搜索使用的区间有两种，第一种是<span class="math inline">\([left, right]\)</span>，第二种是<span class="math inline">\([left,right)\)</span>。这两种的区别就在于，right能否取到。一般来说，一个二分搜索的伪代码如下：</p><div class="code-wrapper"><pre><code class="hljs pseudocode">left = 0right = ??while left ?? right &#123;mid = (right + left) / 2if nums[mid] &gt; target &#123;right = ??&#125; else if nums[mid] &gt; target &#123;left = ??&#125; else &#123;return mid&#125;return -1&#125;</code></pre></div><p>其中??是很容易出错的地方。因为二分的思想很简单，但是写起来就很容易出错。下面针对左闭右闭情况分析。</p><h3 id="左闭右闭">左闭右闭</h3><p>在这种情况下，right是可以取到的。那么针对while里的判断，可以这样想：取到等号的时候，在这个区间的顶一下是否合法？很明显left= right的时候区间仍然合法，因此这里需要写入 &lt;=符号。接下来是right和left的更新。当我们明确的知道mid这个位置的数字不是我们要找的数字的时候，下一次迭代必定要将之排除在外，也就是说下一次的区间一定不能包括这个索引。所以，right应该更新为mid- 1，left更新为mid +1。最后，一开始的right因为是可以取到的，因此我们应该把他设置为长度减一。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = (nums.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;        <span class="hljs-keyword">while</span> left &lt;= right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] == target &#123;                <span class="hljs-keyword">return</span> mid;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] &lt; target &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                right = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        -<span class="hljs-number">1</span>    &#125;&#125;</code></pre></div><h3 id="总结">总结</h3><p>左闭右开区间的分析和左闭右闭是完全一样的。另外在计算mid的时候有可能会造成溢出，因此可以选择我上面代码的方式来计算。</p><p>下面是左闭右开的算法：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = nums.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;        <span class="hljs-keyword">while</span> left &lt; right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] == target &#123;                <span class="hljs-keyword">return</span> mid;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] &lt; target &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                right = mid;            &#125;        &#125;        -<span class="hljs-number">1</span>    &#125;&#125;</code></pre></div><h3 id="其他题目">其他题目</h3><h4 id="搜索插入位置"><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// [left, right)</span><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search_insert</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">while</span> left &lt; right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> nums[mid] == target &#123;                <span class="hljs-keyword">return</span> mid <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>            &#125;        &#125;        right <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>    &#125;&#125;</code></pre></div><h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></h4><p>分别找左右边界。以左边界为例，可以发现左边界的左侧所有值都小于目标值，右侧都大于等于目标值。那么在搜索左边界的时候，只需要逐渐缩小right即可。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search_range</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-built_in">vec!</span>[<span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">get_left_border</span>(&amp;nums, target), <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">get_right_border</span>(&amp;nums, target)]    &#125;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_right_border</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = nums.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;        <span class="hljs-keyword">while</span> left &lt; right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] &gt; target &#123;                right = mid            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> right &lt;= <span class="hljs-number">0</span> || (nums[(right - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] != target) &#123;            -<span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> &#123;            right - <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_left_border</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = nums.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;        <span class="hljs-keyword">while</span> left &lt; right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> nums[mid <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] &gt;= target &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;         &#125;        <span class="hljs-keyword">if</span> left &gt;= nums.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> || nums[left <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] != target &#123;            -<span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> &#123;            left        &#125;    &#125;&#125;</code></pre></div><p>发现了一个非常优雅非常rusty的写法：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search_range</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">if</span> len == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[len - <span class="hljs-number">1</span>] &lt; target &#123;            <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(left), <span class="hljs-title function_ invoke__">Some</span>(right)) = (                <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">lower_bound</span>(&amp;nums, target),                <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">upper_bound</span>(&amp;nums, target)            ) &#123;                <span class="hljs-built_in">vec!</span>[left <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>, right <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> - <span class="hljs-number">1</span>]            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]            &#125;        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lower_bound</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">left</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">find_position</span>(nums, target, |a, b| a &lt; b);        <span class="hljs-keyword">if</span> nums[left] == target &#123;             <span class="hljs-title function_ invoke__">Some</span>(left)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-literal">None</span>        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">upper_bound</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">right</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">find_position</span>(nums, target, |a, b| a &lt;= b);        <span class="hljs-keyword">if</span> nums[right - <span class="hljs-number">1</span>] == target &#123;            <span class="hljs-title function_ invoke__">Some</span>(right)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-literal">None</span>        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_position</span>(        nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;,        target: <span class="hljs-type">i32</span>,        judge: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>,    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">left</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">right</span> = nums.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">while</span> left &lt; right &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">judge</span>(nums[mid], target) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        left    &#125;&#125;</code></pre></div><h4 id="x-的平方根"><a href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">my_sqrt</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">l</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span> = x;        <span class="hljs-keyword">while</span> l &lt;= r &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = ((r - l) / <span class="hljs-number">2</span> + l) <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span>;            <span class="hljs-keyword">if</span> m * m &gt; x <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span> &#123;                r = m <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m * m == x <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span> &#123;                <span class="hljs-keyword">return</span> m <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                l = m <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> + <span class="hljs-number">1</span>;            &#125;        &#125;        r    &#125;&#125;</code></pre></div><h4 id="有效的完全平方数"><a href="https://leetcode.cn/problems/valid-perfect-square/">367.有效的完全平方数</a></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_perfect_square</span>(num: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">l</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span> = num;        <span class="hljs-keyword">while</span> l &lt;= r &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = ((r - l) / <span class="hljs-number">2</span> + l) <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span>;            <span class="hljs-keyword">if</span> m * m &gt; num <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span> &#123;                r = m <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m * m == num <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                l = m <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-literal">false</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rtr-Chapter2</title>
    <link href="/note/Graphics/RealTimeRendering/rtr-chapter2/"/>
    <url>/note/Graphics/RealTimeRendering/rtr-chapter2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有些翻译是我自己认为的翻译，不一定符合常规的翻译</p></blockquote><h1 id="chapter-2-图形渲染管线">Chapter 2 图形渲染管线</h1><h2 id="架构">2.1 架构</h2><p>一个未使用管线的系统，在划分为n个管线子阶段后可以加速n倍。</p><p>实时渲染系统之中可以将渲染管线粗略的分为四个阶段，这些阶段之中又可能包含更细小的管线，也可以并行。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326112819822.png" alt="image-20230326112819822"><figcaption aria-hidden="true">image-20230326112819822</figcaption></figure><p>渲染速度可以通过fps来表示，也可以使用Hertz（HZ）来表示。或者使用渲染一张图像所耗费的时间（ms）。</p><h2 id="application">2.2 Application</h2><p>这个阶段可以被开发者完全控制，因为这个阶段一般运行在CPU。</p><blockquote><p>计算着色器可能会使用GPU来进行计算，但此处仅将其当作一种非常适合并行的高速CPU来看待。</p></blockquote><p>在application的最后阶段会将渲染原语（点、线、三角形）传递给Geometry阶段，这也是application阶段最重要的任务。</p><p>application一般不会被划分为子阶段，而是通过并行来加速。</p><p>这个阶段一般会进行：碰撞检测、处理输入、加速算法。</p><h2 id="geometry-processing">2.3 Geometry Processing</h2><p>这个阶段运行在GPU，主要负责针对每个三角形和顶点的操作。它又被细分为下面三个阶段：</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326114132326.png" alt="image-20230326114132326"><figcaption aria-hidden="true">image-20230326114132326</figcaption></figure><h3 id="vertex-shading">2.3.1 Vertex Shading</h3><ul><li><p>计算顶点位置</p><p>事实上对于物体的渲染大部分就是将光线映射在定点上，然后计算颜色，之后通过插值绘制三角形。这个可编程的处理单元被称为VertexShader。</p><p>模型一开始处于自己的模型空间，此时还没有进行任何变换。但每个模型都可以和一个或多个变换相关联。当关联多个的时候，就可以让模型拥有许多不同的实例而无需从几何原语出发构建。在经过模型变换（ModelTransform）之后，模型就会从自己的模型空间（ModelSpace）转移到世界空间（WorldSpace）。这个时候，所有的模型都会位于同一个世界空间。</p><p>为了便于进行之后的工作，相机和模型都会进行视图变换（ViewTransform）。这个变换的目的是为了把相机放置在原点，并且看向<span class="math inline">\(-z\)</span>方向。同时<span class="math inline">\(y\)</span>轴指向上，<span class="math inline">\(x\)</span>指向右。此时相机和模型会进入视图空间（ViewSpace or Eye Space，或相机空间，Camera Space）。</p><blockquote><p>这里看向-z和z是一样的，他们的区别是语义上的，互相转换很容易。</p></blockquote><p>视图变换和模型变换都可以使用4x4的矩阵来实现。</p></li><li><p>计算顶点的其他属性，例如法线、纹理坐标</p><p>所谓模型的材质，就是如何和光线发生作用。这就被称为着色（Shading）。它涉及到每个点的着色方程。而着色方程所需要的数据将会和顶点保存在一起，传输给后面的极端进行使用。</p><p>事实上投影和裁剪也算是vertex-shading的一部分，他会将ViewVolume变换成一个顶点在（-1，-1，-1）和（1，1，1）的单位立方体。</p><p>常见的投影方式有两种：</p><ul><li><p>正交投影：原先平行的线在变换后仍然平行，是平移和缩放的组合。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326120714123.png" alt="image-20230326120714123"><figcaption aria-hidden="true">image-20230326120714123</figcaption></figure></li><li><p>透视投影：</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326120743481.png" alt="image-20230326120743481"><figcaption aria-hidden="true">image-20230326120743481</figcaption></figure></li></ul><p>投影一般也被表示为一个矩阵。这也导致它可能会和后面的一些变换放在一起来做。</p><p>在这个阶段结束后，模型将会存在于裁剪空间，并会写成齐次坐标形式，以方便之后的操作。</p><p>另外，在这个阶段之后，z坐标将会被丢弃，并存储在z缓冲之中。这也是他们被称为投影变换的原因。</p></li></ul><h3 id="optional-vertex-processing">2.3.2 Optional VertexProcessing</h3><p>在顶点处理之后还有一些可选的步骤：</p><ul><li>Tessellation，曲面细分。可以在模型只有很少数量的三角形的时候，让模型更加逼真。</li><li>Geometry Shader，可以将一些图元转换为另一些图元。</li><li>Stream Output，可以将处理好的数据以数组形式输出。</li></ul><h3 id="clipping">2.3.3 Clipping</h3><p>那些部分在viewvolume之中的物体，需要被裁剪以传递到下一个阶段。而投影阶段将物体投影到cube之中就是为了方便这个阶段的操作：使得每一次的clipping都针对cube。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326145252077.png" alt="image-20230326145252077"><figcaption aria-hidden="true">image-20230326145252077</figcaption></figure><h3 id="screen-mapping">2.3.4 Screen Mapping</h3><p>屏幕映射会将Clipping好的图元映射到一个windowcoordinates，这个坐标系的左下角坐标为（x1， y1），右上为（x2，y2）。另外这个阶段同样会映射z到（z1，z2），z1=0，z2=1。这些东西会传递到光栅阶段。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326150131479.png" alt="image-20230326150131479"><figcaption aria-hidden="true">image-20230326150131479</figcaption></figure><h2 id="rasterization">2.4 Rasterization</h2><p>所谓的pixel，就指的是pixel element</p><p>这个阶段的目标是找到所有的图元内部的点并渲染他们，称之为光栅化。他又会被细分为两个阶段：</p><ul><li><p>triangle setup（primitive assembly）</p><p>会计算一些有关三角形的信息，比如微分、边方程等等，这一步通常有专用的硬件完成</p></li><li><p>triangle traversal</p><p>计算三角形包含哪些像素，并生成一系列和像素一一对应的fragment，其中包含了更多渲染该像素必须的信息。</p></li></ul><h2 id="pixel-processing">2.5 Pixel Processing</h2><p>这个阶段可以被分为pixelshading和merging。主要作用是实施针对每个像素的操作。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326151806829.png" alt="image-20230326151806829"><figcaption aria-hidden="true">image-20230326151806829</figcaption></figure><h3 id="pixel-shading">2.5.1 Pixel Shading</h3><p>插值后的着色数据作为输入，输出一个或多个颜色作为下一个阶段的输入。这个阶段不像光栅化的两个阶段是通过硬件完成的，它可以进行编程控制（也就是熟知的fragmentshader，也可以称作pixel shader）。这个阶段可以处理纹理。</p><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/image-20230326152130938.png" alt="image-20230326152130938"><figcaption aria-hidden="true">image-20230326152130938</figcaption></figure><h3 id="merging">2.5.2 Merging</h3><blockquote><p>也被称为ROP，raster operations pipeline</p></blockquote><p>每个像素的信息被存储在颜色缓冲之中（colorbuffer）。这个阶段的任务就是将目前颜色缓冲之中的颜色和当前计算得到的像素的颜色进行合并。这个阶段的可编程性不强，但是很容易进行配置以产生不同的效果。</p><p>这个阶段还会进行深度测试，不再细说（因为我还算了解）。他还有一些别的buffer，例如alphabuffer，他存储像素的透明度。alpha测试用于保证完全透明的片元不影响深度缓冲。framebuffer用于双缓冲。</p><h2 id="我的总结">我的总结</h2><figure><img src="/note/Graphics/RealTimeRendering/rtr-chapter2/pipeline.jpg" alt="pipeline"><figcaption aria-hidden="true">pipeline</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Real-Time Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rtr-chapter1</title>
    <link href="/note/Graphics/RealTimeRendering/rtr-chapter1/"/>
    <url>/note/Graphics/RealTimeRendering/rtr-chapter1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有些翻译是我自己认为的翻译，不一定符合常规的翻译</p></blockquote><h1 id="chapter-1-介绍">Chapter 1 介绍</h1><h2 id="introduction">1.1 introduction</h2><p>刷新率和帧率是不一样的。帧率是每秒展示的独一无二的图像的数量，也被叫做FPS。刷新率则取决于显示器。当帧率较低时，显示器通过让每个图片显示多次以达到刷新率。当帧率较高时，只有部分图像被显示，同样刷新率不会超过显示器的规格。</p><h2 id="notation-and-definitions">1.2 Notation and Definitions</h2><p>计算机图形学领域常用列向量，但是行向量通常具有更高的可读性。</p><p>在齐次坐标下，点的w坐标被记作1，而向量被记作0。例如：<span class="math inline">\(p=(v_x, v_y, v_z, 1), \quad v=(v_x, v_y, v_z,0)\)</span></p><p><span class="math inline">\(\perp\)</span>操作符是一种一元运算符，可以求得当前向量的垂直向量，例如：<span class="math inline">\(v = (v_x, v_y)^{T}, \quad v^{\perp} = (-v_y,v_x)^{T}\)</span></p><p>还有些比较特殊的操作符： <span class="math display">\[\begin{align*}x^+ &amp;=\begin{cases}        x&amp;\mbox{if x &gt; 0}\\        0&amp;\mbox{otherwise}    \end{cases}    \\\\x^{\mp} &amp;=\begin{cases}        1&amp;\mbox{if x}\ge \mbox{1}\\        x&amp;\mbox{if 0 &lt; x &lt; 1}\\        0&amp;\mbox{otherwise}    \end{cases}\end{align*}\]</span> 有一个c函数经常被使用：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">atan2</span>(y, x); <span class="hljs-comment">// return a angle between [0, 2PI]</span></code></pre></div><p>渲染原语包括<strong>点</strong>、<strong>线</strong>、<strong>三角形</strong>。这些东西和一些更高层面的几何表示（如贝塞尔曲线）可以构成<strong>模型（model）</strong>或<strong>物体（object）</strong>。一个<strong>场景（scene）</strong>之中包含多个模型或物体。</p>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Real-Time Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewMatrix</title>
    <link href="/note/Graphics/Math/ViewTransform/"/>
    <url>/note/Graphics/Math/ViewTransform/</url>
    
    <content type="html"><![CDATA[<h1 id="view变换">View变换</h1><p>之前学习过Games 101，在看过View变换之后一直有个疑惑。记录一下</p><h2 id="数学知识">数学知识</h2><p>同一个位置，在不同的坐标系下有不同的坐标，这是毋庸置疑的。那么我们假设<span class="math inline">\(u=\{u_1, u_2, u_3\}\)</span>和<span class="math inline">\(v=\{v_1, v_2, v_3\}\)</span>是3维线性空间S的两组基。 他们之间可以相互表示，也就是说存在9个标量<span class="math inline">\(\lambda_{ij}\)</span>使得： <span class="math display">\[\begin{align*}u_1 &amp;= \lambda_{11}v_1 + \lambda_{12}v_2 + \lambda_{13}v_3 \\u_2 &amp;= \lambda_{21}v_1 + \lambda_{22}v_2 + \lambda_{23}v_3 \\u_3 &amp;= \lambda_{31}v_1 + \lambda_{32}v_2 + \lambda_{33}v_3\end{align*}\]</span> 写成矩阵形式就是： <span class="math display">\[M = \begin{bmatrix}\lambda_{11} &amp; \lambda_{12} &amp; \lambda_{13} \\\lambda_{21} &amp; \lambda_{22} &amp; \lambda_{23} \\ \lambda_{31} &amp;\lambda_{32} &amp; \lambda_{33} \\ \end{bmatrix}\]</span> 那么上面的式子可以写成： <span class="math display">\[u = M v\]</span>这个M就被称为过渡矩阵。通过矩阵M，可以把向量在u下的表示转换为v下的表示，通过<span class="math inline">\(M^{-1}\)</span>可以把向量在v下的表示转换为在u下的表示。</p><p>现在假设有一个向量<span class="math inline">\(\omega\)</span>，它在u和v下的表示分别为： <span class="math display">\[\begin{align*}w &amp;= a_1v_1 + a_2v_2 + a_3v_3 = a^Tv \\  &amp;= b_1u_1 + b_2u_2 + b_3u_3 = b^Tu\end{align*}\]</span> 其中： <span class="math display">\[\begin{align}a = \begin{bmatrix}a_1 \\ a_2 \\ a_3\end{bmatrix} \\\\b = \begin{bmatrix}b_1 \\ b_2 \\ b_3\end{bmatrix}\end{align}\]</span> 我们有： <span class="math display">\[a^Tv = b^Tu\]</span></p><p>将2式代入4式可得： <span class="math display">\[\begin{align}a = M^Tb \\b = (M^T)^{-1}a = Ta\end{align}\]</span> 其中： <span class="math display">\[M^T = \begin{bmatrix}\lambda_{11} &amp; \lambda_{21} &amp; \lambda_{31}\\ \lambda_{12} &amp; \lambda_{22} &amp; \lambda_{32} \\ \lambda_{13}&amp; \lambda_{23} &amp; \lambda_{33} \\ \end{bmatrix}\]</span>现在我们可以发现：矩阵之中的三个列向量，就是基u在基v下的坐标表示！也就是说：<span class="math display">\[M^T = ([u_1]_v,[u_2]_v,[u_3]_v)\]</span> 对应的矩阵<span class="math inline">\((M^T)^{-1}\)</span>就是v在u下的坐标表示： <span class="math display">\[(M^T)^{-1} = ([v_1]_u, [v_2]_u, [v_3]_u)\]</span> 那么我们可以把5式改写成： <span class="math display">\[[w]_v = [u]_v[w]_u \\[w]_u = [v]_u[w]_v\]</span>我们发现，要在两个基之间转换坐标，只需要求出一个基在另一个基里的坐标表示即可。这个坐标表示构成矩阵<span class="math inline">\(M^T\)</span>或者<span class="math inline">\((M^T)^{-1}\)</span></p><h3 id="举个栗子">举个栗子</h3><p>基u为： <span class="math display">\[u_1=(1, 2, 1, 0), u_2 = (3, 3, 3, 0), u_3 = (2, -10, 0, 0), u_4 = (-2,1, -6, 2)\]</span> 基v为： <span class="math display">\[v_1=(1, 2, 1, 0), v_2 = (1, -1, 1, 0), v_3 = (1, 0, -1, 0), v_4 = (0, 0,0, 2)\]</span> 我们发现： <span class="math display">\[\begin{align*}v_1 &amp;= u_1 \\v_2 &amp;= -2u_1 + u_2 \\v_3 &amp;= 11u_1 - 4u_2 + u_3 \\v_4 &amp;= -27u_1 + 11u_2 - 2u_3 + u_4\end{align*}\]</span> 也就是说： <span class="math display">\[[v]_u = \begin{bmatrix}1 &amp; -2 &amp; 11 &amp; -27 \\ 0 &amp; 1 &amp;-4 &amp; 11 \\ 0 &amp; 0 &amp; 1 &amp; -2 \\ 0 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\]</span> 同理可得： <span class="math display">\[\begin{align*}u_1 &amp;= v_1 \\u_2 &amp;= 2v_1 + v_2 \\u_3 &amp;= -3v_1 + 4v_2 + v_3 \\u_4 &amp;= -v_1 - 3v_2 + 2v_3 + v_4\end{align*}\]</span></p><p><span class="math display">\[[u]_v = \begin{bmatrix}1 &amp; 2 &amp; -3 &amp; -1 \\ 0 &amp; 1 &amp; 4&amp; -3 \\ 0 &amp; 0 &amp; 1 &amp; 2 \\ 0 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\]</span></p><p>现在给定向量<span class="math inline">\(w = (6, -1, 2,2)\)</span>，容易验证： <span class="math display">\[\begin{align}w = v_1 + 3v_2 + 2v_3 + v_4 \\[w]_v = \begin{bmatrix}1 \\ 3 \\ 2 \\ 1\end{bmatrix}\end{align}\]</span> 那么 <span class="math display">\[[w]_u=[v]_u[w]_v = \begin{bmatrix}1 &amp; -2 &amp; 11 &amp; -27 \\ 0&amp; 1 &amp; -4 &amp; 11 \\ 0 &amp; 0 &amp; 1 &amp; -2 \\ 0 &amp; 0&amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}1 \\ 3 \\ 2 \\ 1\end{bmatrix}= \begin{bmatrix}-10 \\ 6 \\ 0 \\ 1\end{bmatrix}\]</span> 容易验证： <span class="math display">\[\begin{align}w = -10u_1 + 6u_2 + u_4 \\[u]_v^{-1} = [v]_u\end{align}\]</span> 总结一下就是，现在有两个坐标系<span class="math inline">\(f_1\)</span>和<span class="math inline">\(f_2\)</span>，我们想要获得在<span class="math inline">\(f_2\)</span>下的物体在<span class="math inline">\(f_1\)</span>之中的表示，就需要：</p><ul><li>使用<span class="math inline">\(f_1\)</span>表示<span class="math inline">\(f_2\)</span>，获得一个矩阵</li><li>将这个矩阵乘以该物体使用<span class="math inline">\(f_2\)</span>表示出来的矩阵</li></ul><p>即可。</p><h3 id="要点">要点</h3><p>事实上，线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示。</p><p>先看这样一个图：</p><figure><img src="/note/Graphics/Math/ViewTransform/image-20230322214554190.png" alt="image-20230322214554190"><figcaption aria-hidden="true">image-20230322214554190</figcaption></figure><p>a点的坐标是(1, 1)，可以表示为 <span class="math display">\[\begin{align*}oa &amp;= 1 \cdot i + 1 \cdot j \\   &amp;= 1 \cdot \begin{bmatrix}1 \\ 0\end{bmatrix} + 1 \cdot\begin{bmatrix}0 \\ 1\end{bmatrix} \\   &amp;= \begin{bmatrix}1 \\ 1\end{bmatrix}\end{align*}\]</span> 接下来旋转45°，</p><figure><img src="/note/Graphics/Math/ViewTransform/image-20230322215505752.png" alt="image-20230322215505752"><figcaption aria-hidden="true">image-20230322215505752</figcaption></figure><p>可以看到现在的坐标系下， <span class="math display">\[\begin{align*}oa &amp;= 1 \cdot i + 1 \cdot j \\   &amp;= 1 \cdot \begin{bmatrix}\frac{\sqrt2}{2}\\\frac{\sqrt2}{2}\end{bmatrix} + 1 \cdot\begin{bmatrix}-\frac{\sqrt2}{2} \\ \frac{\sqrt2}{2}\end{bmatrix} \\   &amp;= \begin{bmatrix}\frac{\sqrt2}{2} &amp; -\frac{\sqrt2}{2} \\\frac{\sqrt2}{2} &amp; \frac{\sqrt2}{2}\end{bmatrix} \begin{bmatrix}1 \\1\end{bmatrix} \\   &amp;= \begin{bmatrix}0 \\ \sqrt2\end{bmatrix}\end{align*}\]</span> 好了，现在可以发现这个规律了。</p><blockquote><p>线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示。</p></blockquote><p>另外，我们其实可以发现，在你对整个坐标系进行线性变换后，如果对原来的坐标不加更改的话，才是在新坐标系下的坐标，假如使用变换矩阵的话，就是在原坐标系下表示！</p><p>例如A(1, ,1)，计算MatA · A =B得到的B是经过线性变换后A的坐标，还是使用的<span class="math inline">\(xyzo\)</span>表示，而A本身则是使用了<span class="math inline">\(x_2y_2z_2o\)</span>表示。所以MatA的作用其实是将新坐标系下点的坐标转换为原坐标系下点的坐标。这一点记住了，对于以后的理解很有帮助。</p><h2 id="view">View</h2><p>视图变化就是：我们将世界坐标系经过旋转平移移动到摄像机坐标系，并对世界坐标系内原有的顶点坐标做出同样的变换。<span class="math display">\[view = [R_w]_c[T_w]_c = [R_c]_w^{-1}[T_c]_w^{-1}\]</span> 首先是简单的旋转变换： <span class="math display">\[[R_c]_w = \begin{bmatrix}s_x &amp; u_x &amp; -f_x &amp; 0\\s_y &amp; u_y&amp; -f_y &amp; 0\\s_z &amp; u_z &amp; -f_z &amp; 0\\0 &amp; 0 &amp; 0&amp; 1\end{bmatrix}\]</span> 然后是更简单的平移变换： <span class="math display">\[[T_c]_w = \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; e_x \\ 0 &amp; 1 &amp;0 &amp; e_y \\  0 &amp; 0 &amp; 1 &amp; e_z \\  0 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\]</span> 接下来就好求了： <span class="math display">\[\begin{align*}view &amp;= [R_c]_w^{-1}[T_c]_w^{-1} \\     &amp;= \begin{bmatrix}s_x &amp; s_y &amp; s_z &amp; 0 \\ u_x &amp;u_y &amp; u_z &amp; 0  \\ -f_x &amp; -f_y &amp; -f_z &amp; 0 \\ 0 &amp;0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0 &amp;-e_x \\ 0 &amp; 1 &amp; 0 &amp; -e_y \\  0 &amp; 0 &amp; 1 &amp; -e_z\\  0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} \\     &amp;= \begin{bmatrix}s_x &amp; s_y &amp; s_z &amp; -(s\cdot e) \\u_x &amp; u_y &amp; u_z &amp; -(u\cdot e) \\ -f_x &amp; -f_y &amp; -f_z&amp; f\cdot e \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\end{align*}\]</span> 而lookat函数，事实上就是在求view矩阵。</p><h3 id="另一种较为直接的办法">另一种较为直接的办法</h3><p>事实上，这就是在变换坐标系，我们需要把坐标从世界坐标变换到相机坐标系。<span class="math display">\[[p]_{camera} = [world]_{camera}[p]_{world} =[camera]_{world}^{-1}[p]_{world} = view[p]_{world}\]</span> 我们需要求的<span class="math inline">\([camera]_{world}^{-1}\)</span>，就是camera在world下的表示，并求逆。<span class="math display">\[\begin{align*}view &amp;= [camera]_{world}^{-1} \\     &amp;= \begin{bmatrix}s[0] &amp; s[1] &amp; s[2] &amp; -dot(s, eye)\\ u[0] &amp; u[1] &amp; u[2] &amp; -dot(u, eye) \\ -f[0] &amp; -f[1]&amp; -f[2] &amp; dot(f, eye) \\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\end{align*}\]</span> 本文参考了：</p><p><a href="https://blog.csdn.net/weixin_44179561/article/details/124149297">[OpenGL]视图矩阵...</a></p><p><a href="https://blog.csdn.net/wangdingqiaoit/article/details/51394238">OpenGL学习脚印:坐标...</a></p><p><a href="https://pengfeixc.com/blogs/computer-graphics/3D-matrix-transformation-part-two">3D图形学中的矩阵变换（二）</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744/?p=3&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=7af60262c7cccf863e49fcf16456f9bc">Games101</a></p>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transform</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
